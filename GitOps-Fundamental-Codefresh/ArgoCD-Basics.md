# Module-2: ArgoCD Basics

---

### Introduction to ArgoCD

- As a GitOps Controller â†’ [ArgoCD](https://argo-cd.readthedocs.io/en/stable/)
- ArgoCD implements all the GitOps principles:
    - It is installed as a **controller** in your Kubernetes cluster (the same cluster that it has to manage)
    - ArgoCD is flexible on the types of manifests we can use (stored in Git). 
    It supports:
        - Kubernetes manifests
        - Helm Charts
        - Kustomize definitions
        - Otherâ€¦..
    - ArgoCD application can be created by defining:
        1. which Git repository to monitor
        2. to which cluster/namespace this application should be installed.
    - From there, ArgoCD monitors the Git repo & whenever there is a change, it automatically bring the deployed cluster to the samt state (desired state)
    - ArgoCD can also deploy applications on other clusters as well
        
        ![](https://codimd.s3.shivering-isles.com/demo/uploads/4c565faa-e8a6-40ae-a743-ff1fce10ac14.png)
        

---

- Argo Family Of Projects:
    1. **ArgoCD** - GitOps Controller
    2. **Argo Rollouts** - Progressive Delivery Controller
    3. **Argo Workflows** - Workflow engine for Kubernetes
    4. **Argo Events** - Event Handling for Kubernetes

---

### ArgoCD Installation

- ArgoCD is an application itself. Therefore, it needs to be installed
- For production setup, [ArgoCD Auto-pilot](https://github.com/argoproj-labs/argocd-autopilot) is recommended
- ArgoCD UI can be available to the external traffic via a [Kubernetes Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/)
    - **Kubernetes Ingress** - An API object that manages external access to the services in a cluster, typically HTTP.

---

### Hands-On Lab

**01 Setup ArgoCD** (Installing ArgoCD on a cluster)

- Weâ€™ll be using simple Kubernetes manifests for the ArgoCD installation.
- In a real cluster you would use aÂ [Helm chart](https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd)
orÂ [Argo CD autopilot](https://argocd-autopilot.readthedocs.io/en/stable/) which allows you to manage Argo CD with itself.
- Create a new namespace called argocd:
    
    ```bash
    kubectl create namespace argocd
    ```
    
    ![](https://codimd.s3.shivering-isles.com/demo/uploads/80e1c681-4351-4c6a-a2e2-2f4cd7ba1bd9.png)
    
    - This where Argo CD services and application resources will live.
- Update the config file with this namespace & install argoCD:
    
    ```bash
    kubectl apply -n argocd -f https://raw.githubusercontent.com/codefresh-contrib/gitops-certification-examples/main/argocd-noauth/install.yaml
    ```
    
- View the deployment using:
    
    ```bash
    kubectl get pods -n argocd
    ```
    
    ![](https://codimd.s3.shivering-isles.com/demo/uploads/d1440bcf-b9d6-42aa-a1f6-e7b2e4921407.png)
    

---

- By default, Argo CD is only accessible from within the cluster.
- To expose the UI to users you can utilize any of the standard Kubernetes networking mechanisms such as
    - **Ingress** (recommended for production)
    - **Load balancer** (affects cloud cost)
    - **NodePort** (simple but not very flexible)
        - [https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)
        - An abstract way to expose an application running on a set ofÂ [Pods](https://kubernetes.io/docs/concepts/workloads/pods/) as a network service.
        - Exposes the Service on each Node's IP at a static port (theÂ ***NodePort***)
- Standard NodePort service resource we are using:
    
    ```yaml
    apiVersion: v1
    kind: Service
    metadata:
      labels:
        app: argocd-server
      managedFields:
      name: argocd-server-nodeport
      namespace: argocd
    spec:
      ports:
      - nodePort: 30443
        port: 8080
        protocol: TCP
      selector:
        app.kubernetes.io/name: argocd-server
      type: NodePort
    ```
    
- To apply this in a cluster:
    
    ```bash
    kubectl apply -f service.yml
    ```
    
    ![](https://codimd.s3.shivering-isles.com/demo/uploads/964b27ee-a7ce-4160-af45-94b9e9144949.png)

---

**Log in the ArgoCD UI**

- Argo CD initially has an admin user with an autogenerated password. You can get the admin password from the default Configmap:
    
    ```bash
    kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d > admin-pass.txt
    ```
    
- Default username - admin
- You can get the default password from the file `admin-pass.txt`
    
    ```bash
    cat admin-pass.txt
    ```
    
---

### Creating an ArgoCD application

- There are 3 ways an application can be created in ArgoCD:
    1. Using the UI
    2. CLI
    3. Writing custom Kuberntes manifests, which can be passed to `kubectl`, to create resources

---

- **Using the UI**
    - Using the following info:
        - application name :Â `demo`
        - project:Â `default`
        - repository URL:Â [https://github.com/verma-kunal/DevOps-90](https://github.com/verma-kunal/DevOps-90/tree/main/Certifications/GitOps-Fundamentals-By-Codefresh/Hands-On-Files)
        - path:Â `./Certifications/GitOps-Fundamentals-By-Codefresh/Hands-On-Files`
        - Cluster:Â [https://kubernetes.default.svc](https://kubernetes.default.svc/)Â (this is the same cluster where ArgoCD is installed)
        - Namespace:Â `default`
    - Hit the `Create` button
    - Weâ€™ll se an initial state of the application as below:
        
        ![](https://i.imgur.com/Bz0o80C.png)
        
        - Here, `OutOfSync` state means that:
            1. the cluster is empty
                - You can check this by doing:
                    
                    ```bash
                    kubectl get deployments
                    ```
                    
            2. The Git repository has an application
                - Therefore, the Git & cluster state are different
    - **Syncing in ArgoCD**
        - This means that, we want to match the state described in Git to that of whats in the cluster.
        - Using the UI, we can directly hit the `Sync` button & that would match the Git state with the cluster state
        - Our app should now be deployed ðŸŽ‰
            
            ![](https://i.imgur.com/W1h7TGw.png)
            
            - To check we can do:
                
                ```bash
                kubectl get deployments
                
                # Output:
                NAME                READY   UP-TO-DATE   AVAILABLE   AGE
                simple-deployment   1/1     1            1           61s
                ```
                
    
- **Using the CLI**
    - Some handy commands:
        1. The list of all the apps & their info
        
        ```bash
        argocd app list
        ```
        
        1. Get info of a specific app 
            
            Example: `demo` app
            
            ```bash
            argocd app get demo
            
            # Output:
            Name:               demo
            Project:            default
            Server:             https://kubernetes.default.svc
            Namespace:          default
            URL:                https://localhost:30443/applications/demo
            Repo:               https://github.com/verma-kunal/DevOps-90
            Target:             HEAD
            Path:               ./Certifications/GitOps-Fundamentals-By-Codefresh/Hands-On-Files
            SyncWindow:         Sync Allowed
            Sync Policy:        <none>
            Sync Status:        Synced to HEAD (1047b67)
            Health Status:      Healthy
            
            GROUP  KIND        NAMESPACE  NAME               STATUS  HEALTH   HOOK  MESSAGE
                   Service     default    simple-service     Synced  Healthy        service/simple-service created
            apps   Deployment  default    simple-deployment  Synced  Healthy        deployment.apps/simple-deployment created
            ```
            
        2. Deleting a specific app (`demo`)
            
            ```bash
            argocd app delete demo
            ```
            
    
    ---
    
    **Deploying an app using the CLI**
    
    - Creating the app: (`demo-kunal`)
        
        ```bash
        argocd app create demo-kunal \
        > --project default \
        > --repo https://github.com/verma-kunal/DevOps-90 \
        > --path "./Certifications/GitOps-Fundamentals-By-Codefresh/Hands-On-Files" \
        > --dest-namespace default \
        > --dest-server https://kubernetes.default.svc
        
        # Output:
        
        application 'demo-kunal' created
        ```
        
    - Syncing the app:
        
        ```bash
        argocd app sync demo-kunal
        ```
        
- **Points to Remember**
    - `Argo CD` is a standalone project. It works great with the other Argo projects, but it does not depend on them.
    - How does ArgoCD interact with clusters?
        - You can have any combination of clusters and ArgoCD instances. ArgoCD can deploy applications on the cluster it is installed on, or other external clusters that are authenticated correctly

---